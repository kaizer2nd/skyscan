"""
Industry-Standard Vulnerability Scanner
Performs comprehensive security checks on a single target
"""
import socket
import ssl
import requests
import urllib3
from datetime import datetime
from typing import Dict, List, Optional, Any
from urllib.parse import urlparse, urljoin
import logging

# Disable SSL warnings for testing
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

logger = logging.getLogger(__name__)


class VulnerabilityScanner:
    """Professional vulnerability scanner following industry standards"""
    
    # Industry-standard common ports to scan
    COMMON_PORTS = [21, 22, 25, 53, 80, 110, 143, 443, 445, 3306, 8080]
    
    # Security headers to check
    SECURITY_HEADERS = {
        'Strict-Transport-Security': 'HSTS',
        'X-Frame-Options': 'Clickjacking Protection',
        'X-XSS-Protection': 'XSS Protection',
        'Content-Security-Policy': 'CSP',
        'X-Content-Type-Options': 'MIME Sniffing Protection',
        'Permissions-Policy': 'Permissions Policy',
    }
    
    # Common directories to probe
    COMMON_DIRECTORIES = ['admin', 'login', 'dashboard', 'config', 'api', 'backup']
    
    # Sensitive files to check
    SENSITIVE_FILES = ['.env', '.git/config', 'backup.zip', 'database.sql', 'config.php', 'wp-config.php']
    
    # SQL injection test payloads (harmless)
    SQL_PAYLOADS = ["'", "' OR '1'='1", "1' OR '1'='1", "admin'--", "' OR 1=1--"]
    
    def __init__(self):
        self.timeout = 3
        self.user_agent = 'SkyScan-VulnerabilityScanner/1.0'
    
    def normalize_target(self, target: str) -> tuple[str, str]:
        """
        Normalize and validate target input
        Returns: (url, ip)
        """
        target = target.strip()
        
        # Add http:// if no scheme present
        if not target.startswith(('http://', 'https://')):
            # Try to detect if it's a domain or IP
            if '.' in target and not target.replace('.', '').isdigit():
                target = f'https://{target}'  # Assume HTTPS for domains
            else:
                target = f'http://{target}'  # HTTP for IPs
        
        parsed = urlparse(target)
        url = f"{parsed.scheme}://{parsed.netloc}"
        
        # Resolve IP
        try:
            hostname = parsed.netloc.split(':')[0]
            ip = socket.gethostbyname(hostname)
        except socket.gaierror:
            ip = parsed.netloc.split(':')[0]  # Use as-is if can't resolve
        
        return url, ip
    
    async def scan(self, target: str) -> Dict[str, Any]:
        """
        Main scanning function - performs all security checks
        """
        logger.info(f"Starting vulnerability scan for target: {target}")
        
        try:
            url, ip = self.normalize_target(target)
        except Exception as e:
            return {
                'error': f'Invalid target: {str(e)}',
                'target': target,
                'timestamp': datetime.utcnow().isoformat()
            }
        
        report = {
            'target': url,
            'ip': ip,
            'timestamp': datetime.utcnow().isoformat(),
            'scan_type': 'Comprehensive Vulnerability Scan',
            'checks': {}
        }
        
        # Perform all checks
        report['checks']['port_scan'] = self.scan_ports(ip)
        report['checks']['header_security'] = self.check_http_headers(url)
        report['checks']['ssl_certificate'] = self.check_ssl_certificate(url)
        report['checks']['directory_discovery'] = self.discover_directories(url)
        report['checks']['exposed_files'] = self.check_exposed_files(url)
        report['checks']['sql_injection'] = self.test_sql_injection(url)
        
        # Calculate overall severity score
        report['severity_score'] = self.calculate_severity_score(report['checks'])
        report['risk_level'] = self.get_risk_level(report['severity_score'])
        
        return report
    
    def scan_ports(self, ip: str) -> Dict[str, Any]:
        """
        Scan common industry-standard ports
        """
        logger.info(f"Scanning ports for {ip}")
        results = {
            'ports': [],
            'open_count': 0,
            'closed_count': 0,
            'filtered_count': 0
        }
        
        for port in self.COMMON_PORTS:
            status = self._check_port(ip, port)
            results['ports'].append({
                'port': port,
                'status': status,
                'service': self._get_service_name(port)
            })
            
            if status == 'open':
                results['open_count'] += 1
            elif status == 'closed':
                results['closed_count'] += 1
            else:
                results['filtered_count'] += 1
        
        logger.info(f"Port scan complete: {results['open_count']} open, {results['closed_count']} closed")
        return results
    
    def _check_port(self, ip: str, port: int) -> str:
        """Check if a port is open, closed, or filtered"""
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(self.timeout)
        
        try:
            result = sock.connect_ex((ip, port))
            if result == 0:
                return 'open'
            else:
                return 'closed'
        except socket.timeout:
            return 'filtered'
        except Exception as e:
            logger.debug(f"Port {port} check error: {e}")
            return 'filtered'
        finally:
            sock.close()
    
    def _get_service_name(self, port: int) -> str:
        """Get common service name for port"""
        services = {
            21: 'FTP',
            22: 'SSH',
            25: 'SMTP',
            53: 'DNS',
            80: 'HTTP',
            110: 'POP3',
            143: 'IMAP',
            443: 'HTTPS',
            445: 'SMB',
            3306: 'MySQL',
            8080: 'HTTP-Alt'
        }
        return services.get(port, 'Unknown')
    
    def check_http_headers(self, url: str) -> Dict[str, Any]:
        """
        Check HTTP security headers
        """
        logger.info(f"Checking HTTP headers for {url}")
        results = {
            'url': url,
            'missing_headers': [],
            'present_headers': [],
            'risky_headers': [],
            'status': 'unknown'
        }
        
        try:
            response = requests.get(
                url,
                timeout=self.timeout,
                verify=False,
                headers={'User-Agent': self.user_agent},
                allow_redirects=True
            )
            
            headers = response.headers
            
            # Check security headers
            for header, description in self.SECURITY_HEADERS.items():
                if header in headers:
                    results['present_headers'].append({
                        'header': header,
                        'description': description,
                        'value': headers[header][:50]  # Truncate long values
                    })
                else:
                    results['missing_headers'].append({
                        'header': header,
                        'description': description
                    })
            
            # Check for risky headers
            if 'Server' in headers:
                results['risky_headers'].append({
                    'header': 'Server',
                    'issue': 'Technology stack exposed',
                    'value': headers['Server']
                })
            
            if 'X-Powered-By' in headers:
                results['risky_headers'].append({
                    'header': 'X-Powered-By',
                    'issue': 'Technology information leak',
                    'value': headers['X-Powered-By']
                })
            
            # Determine status
            missing_count = len(results['missing_headers'])
            if missing_count == 0:
                results['status'] = 'Excellent'
            elif missing_count <= 2:
                results['status'] = 'Good'
            elif missing_count <= 4:
                results['status'] = 'Needs Improvement'
            else:
                results['status'] = 'Poor'
            
        except requests.exceptions.RequestException as e:
            logger.warning(f"HTTP header check failed: {e}")
            results['error'] = str(e)
            results['status'] = 'Failed'
        
        return results
    
    def check_ssl_certificate(self, url: str) -> Dict[str, Any]:
        """
        Check SSL/TLS certificate validity
        """
        results = {
            'url': url,
            'is_https': False,
            'status': 'N/A'
        }
        
        parsed = urlparse(url)
        if parsed.scheme != 'https':
            results['message'] = 'Not an HTTPS URL'
            return results
        
        results['is_https'] = True
        hostname = parsed.netloc.split(':')[0]
        port = parsed.port or 443
        
        logger.info(f"Checking SSL certificate for {hostname}:{port}")
        
        try:
            context = ssl.create_default_context()
            
            with socket.create_connection((hostname, port), timeout=self.timeout) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    cert = ssock.getpeercert()
                    
                    # Parse expiry date
                    not_after = cert.get('notAfter')
                    if not_after:
                        expiry_date = datetime.strptime(not_after, '%b %d %H:%M:%S %Y %Z')
                        days_until_expiry = (expiry_date - datetime.utcnow()).days
                        
                        results['expiry_date'] = expiry_date.isoformat()
                        results['days_until_expiry'] = days_until_expiry
                        
                        if days_until_expiry < 0:
                            results['status'] = 'Expired'
                            results['rating'] = 'Critical'
                        elif days_until_expiry < 30:
                            results['status'] = 'Expiring Soon'
                            results['rating'] = 'Warning'
                        else:
                            results['status'] = 'Valid'
                            results['rating'] = 'Good'
                    
                    # Check signature algorithm
                    results['issuer'] = dict(x[0] for x in cert.get('issuer', []))
                    results['subject'] = dict(x[0] for x in cert.get('subject', []))
                    
        except ssl.SSLError as e:
            logger.warning(f"SSL check failed: {e}")
            results['error'] = str(e)
            results['status'] = 'Invalid'
            results['rating'] = 'Poor'
        except Exception as e:
            logger.warning(f"SSL check error: {e}")
            results['error'] = str(e)
            results['status'] = 'Failed'
            results['rating'] = 'Unknown'
        
        return results
    
    def discover_directories(self, url: str) -> Dict[str, Any]:
        """
        Discover common directories/endpoints
        """
        logger.info(f"Discovering directories for {url}")
        results = {
            'url': url,
            'endpoints': [],
            'found_count': 0,
            'not_found_count': 0
        }
        
        for directory in self.COMMON_DIRECTORIES:
            endpoint_url = urljoin(url, f'/{directory}')
            
            try:
                response = requests.get(
                    endpoint_url,
                    timeout=self.timeout,
                    verify=False,
                    headers={'User-Agent': self.user_agent},
                    allow_redirects=False
                )
                
                status_code = response.status_code
                found = status_code < 400
                
                results['endpoints'].append({
                    'path': f'/{directory}',
                    'status_code': status_code,
                    'found': found,
                    'url': endpoint_url
                })
                
                if found:
                    results['found_count'] += 1
                else:
                    results['not_found_count'] += 1
                    
            except requests.exceptions.RequestException as e:
                logger.debug(f"Directory check failed for {directory}: {e}")
                results['endpoints'].append({
                    'path': f'/{directory}',
                    'status_code': 0,
                    'found': False,
                    'error': str(e)
                })
                results['not_found_count'] += 1
        
        return results
    
    def check_exposed_files(self, url: str) -> Dict[str, Any]:
        """
        Check for exposed sensitive files
        """
        logger.info(f"Checking for exposed files on {url}")
        results = {
            'url': url,
            'files': [],
            'exposed_count': 0,
            'safe_count': 0
        }
        
        for filename in self.SENSITIVE_FILES:
            file_url = urljoin(url, f'/{filename}')
            
            try:
                response = requests.get(
                    file_url,
                    timeout=self.timeout,
                    verify=False,
                    headers={'User-Agent': self.user_agent},
                    allow_redirects=False
                )
                
                is_exposed = response.status_code == 200
                severity = 'HIGH' if is_exposed else 'SAFE'
                
                results['files'].append({
                    'filename': filename,
                    'url': file_url,
                    'status_code': response.status_code,
                    'exposed': is_exposed,
                    'severity': severity
                })
                
                if is_exposed:
                    results['exposed_count'] += 1
                else:
                    results['safe_count'] += 1
                    
            except requests.exceptions.RequestException as e:
                logger.debug(f"File check failed for {filename}: {e}")
                results['files'].append({
                    'filename': filename,
                    'exposed': False,
                    'severity': 'SAFE',
                    'error': str(e)
                })
                results['safe_count'] += 1
        
        return results
    
    def test_sql_injection(self, url: str) -> Dict[str, Any]:
        """
        Basic SQL injection probing (harmless payloads)
        """
        logger.info(f"Testing SQL injection for {url}")
        results = {
            'url': url,
            'vulnerable': False,
            'risk_level': 'Low',
            'tests': []
        }
        
        # SQL error patterns
        sql_errors = [
            'SQL syntax',
            'mysql_fetch',
            'mysqli',
            'ORA-',
            'PostgreSQL',
            'SQLite',
            'SQLSTATE',
            'syntax error',
            'unclosed quotation mark'
        ]
        
        for payload in self.SQL_PAYLOADS:
            test_url = f"{url}?id={payload}"
            
            try:
                response = requests.get(
                    test_url,
                    timeout=self.timeout,
                    verify=False,
                    headers={'User-Agent': self.user_agent}
                )
                
                # Check for SQL errors in response
                content = response.text.lower()
                detected_errors = [error for error in sql_errors if error.lower() in content]
                
                has_error = len(detected_errors) > 0
                
                results['tests'].append({
                    'payload': payload,
                    'sql_error_detected': has_error,
                    'detected_patterns': detected_errors
                })
                
                if has_error:
                    results['vulnerable'] = True
                    results['risk_level'] = 'High'
                    
            except requests.exceptions.RequestException as e:
                logger.debug(f"SQL injection test failed for payload {payload}: {e}")
                results['tests'].append({
                    'payload': payload,
                    'error': str(e)
                })
        
        if not results['vulnerable']:
            results['message'] = 'No obvious SQL injection vulnerabilities detected'
        else:
            results['message'] = 'Potential SQL injection vulnerability found'
        
        return results
    
    def calculate_severity_score(self, checks: Dict[str, Any]) -> int:
        """
        Calculate overall severity score (0-100)
        Lower is better, higher means more vulnerabilities
        """
        score = 0
        
        # Port scan scoring (max 25 points)
        port_scan = checks.get('port_scan', {})
        open_ports = port_scan.get('open_count', 0)
        sensitive_ports = [21, 22, 25, 3306, 445]  # FTP, SSH, SMTP, MySQL, SMB
        
        for port_info in port_scan.get('ports', []):
            if port_info['status'] == 'open' and port_info['port'] in sensitive_ports:
                score += 5
        
        # Header security scoring (max 20 points)
        headers = checks.get('header_security', {})
        missing_count = len(headers.get('missing_headers', []))
        score += missing_count * 3
        score += len(headers.get('risky_headers', [])) * 2
        
        # SSL certificate scoring (max 20 points)
        ssl = checks.get('ssl_certificate', {})
        if ssl.get('is_https'):
            if ssl.get('status') == 'Expired':
                score += 20
            elif ssl.get('status') == 'Expiring Soon':
                score += 10
            elif ssl.get('status') == 'Invalid':
                score += 15
        else:
            score += 10  # No HTTPS is a concern
        
        # Directory discovery scoring (max 15 points)
        directories = checks.get('directory_discovery', {})
        found_count = directories.get('found_count', 0)
        score += min(found_count * 3, 15)
        
        # Exposed files scoring (max 15 points)
        files = checks.get('exposed_files', {})
        exposed_count = files.get('exposed_count', 0)
        score += exposed_count * 15  # Very critical
        
        # SQL injection scoring (max 5 points)
        sql = checks.get('sql_injection', {})
        if sql.get('vulnerable'):
            score += 25  # Critical vulnerability
        
        return min(score, 100)
    
    def get_risk_level(self, score: int) -> str:
        """
        Convert severity score to risk level
        """
        if score >= 70:
            return 'High'
        elif score >= 40:
            return 'Medium'
        else:
            return 'Low'
